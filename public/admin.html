<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Admin - Thread Management</title>

    <!-- PWA Manifest -->
    <link rel="manifest" href="/manifest.json">

    <!-- iOS Specific -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Admin">
    <link rel="apple-touch-icon" href="/assets/icons/apple-touch-icon.png">

    <!-- Theme Colors -->
    <meta name="theme-color" content="#0066cc">
    <link rel="stylesheet" href="assets/css/tokens.css">
    <link rel="stylesheet" href="assets/css/admin.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.11.1/styles/github-dark.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/highlight.js@11.11.1/lib/common.min.js"></script>
</head>
<body>
    <!-- Connection Status Indicator -->
    <div id="connection-status" class="connection-status">
        <span id="connection-text">‚óè  Connected</span>
    </div>

    <div class="container">
        <!-- Login Form -->
        <div id="login-screen" class="login-form">
            <h1>üîê Admin Login</h1>
            <div id="login-error" class="error hidden"></div>
            <input type="password" id="password-input" placeholder="Enter admin password" />
            <button onclick="app.login()">Login</button>
        </div>

        <div id="admin-tabs" class="admin-tabs hidden">
            <button id="tab-inbox" class="admin-tab-button active" onclick="app.switchTab('inbox')">Inbox</button>
            <button id="tab-blog" class="admin-tab-button" onclick="app.switchTab('blog')">Blog</button>
        </div>

        <!-- Thread List -->
        <div id="thread-list-screen" class="hidden">
            <div class="thread-list">
                <h1>üí¨ Conversations</h1>
                <button onclick="app.refresh()" class="secondary" style="margin-bottom: 16px;">Refresh</button>
                <div id="threads-container" class="loading">Loading...</div>
            </div>
        </div>

        <!-- Blog Publisher -->
        <div id="blog-screen" class="hidden">
            <div class="blog-layout">
                <div class="blog-sidebar">
                    <div class="blog-sidebar-header">
                        <h1>üìù Blog Publisher</h1>
                        <div style="display:flex; gap:8px;">
                            <button class="secondary" onclick="app.loadBlogPosts(true)">Refresh</button>
                            <button onclick="app.newBlogPost()">New Post</button>
                        </div>
                    </div>
                    <div id="blog-stats" class="blog-stats">
                        <span>Total posts: 0</span>
                        <span>Total words: 0</span>
                    </div>
                    <div id="blog-posts-list" class="blog-posts-list">
                        <div class="loading">Loading...</div>
                    </div>
                </div>
                <div class="blog-editor">
                    <h2 id="blog-editor-title">Create Post</h2>
                    <div id="blog-editor-status" class="success hidden"></div>
                    <div id="blog-editor-error" class="error hidden"></div>
                    <div class="blog-editor-grid">
                        <form id="blog-form" class="blog-form" onsubmit="app.submitBlogForm(event)">
                            <div>
                                <label for="blog-title">Title</label>
                                <input type="text" id="blog-title" placeholder="Post title" required />
                            </div>
                            <div>
                                <label for="blog-slug">Slug</label>
                                <input type="text" id="blog-slug" placeholder="auto-generated if left blank" />
                                <small>Lowercase, hyphenated (e.g. agent-benchmark-notes)</small>
                            </div>
                            <div>
                                <label for="blog-summary">Summary</label>
                                <textarea id="blog-summary" rows="3" placeholder="Optional teaser shown on /blog"></textarea>
                            </div>
                            <div>
                                <label for="blog-tags">Tags</label>
                                <input type="text" id="blog-tags" placeholder="Comma-separated tags (e.g. agents,infra)" />
                            </div>
                            <div>
                                <label for="blog-hero-image">Hero Image URL</label>
                                <input type="text" id="blog-hero-image" placeholder="Optional hero image URL" />
                            </div>
                            <div>
                                <label for="blog-status">Status</label>
                                <select id="blog-status">
                                    <option value="draft">Draft</option>
                                    <option value="published">Published</option>
                                </select>
                            </div>
                            <div>
                                <label for="blog-published-at">Published At</label>
                                <input type="datetime-local" id="blog-published-at" />
                                <small>Defaults to now when publishing. Adjust to backdate posts.</small>
                            </div>
                            <div>
                                <label for="blog-content">Markdown Content</label>
                                <textarea id="blog-content" placeholder="# Hello World&#10;&#10;Write Markdown or paste it here." required></textarea>
                            </div>
                            <div class="blog-editor-actions">
                                <button type="submit">Save Post</button>
                                <button type="button" class="secondary" onclick="app.resetBlogForm()">Clear</button>
                            </div>
                        </form>
                        <div class="blog-preview-wrapper">
                            <div class="blog-preview-header">Live Preview</div>
                            <div id="blog-preview" class="blog-preview-body">
                                <p class="blog-preview-empty">Start typing to see the live preview.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Conversation View -->
        <div id="conversation-screen" class="hidden">
            <div class="conversation">
                <div class="conversation-header">
                    <button onclick="app.showThreadList()" class="back-button">‚Üê Back to List</button>
                    <h2 id="conv-title"></h2>
                    <div id="conv-meta" class="meta"></div>
                </div>

                <div id="messages-container"></div>

                <div class="reply-section">
                    <div id="reply-success" class="success hidden">Reply sent!</div>
                    <textarea id="reply-text" placeholder="Type your reply..." rows="3"></textarea>
                    <button onclick="app.sendReply()">Send Reply</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Fetch VAPID public key
        let vapidPublicKey = null;
        let vapidKeyLoaded = false;
        fetch('/api/push/vapid-public-key')
            .then(res => {
                if (!res.ok) {
                    throw new Error(`VAPID key fetch failed: ${res.status}`);
                }
                return res.json();
            })
            .then(data => {
                if (!data.publicKey) {
                    throw new Error('VAPID public key missing in response');
                }
                window.vapidPublicKey = data.publicKey;
                vapidPublicKey = data.publicKey;
                vapidKeyLoaded = true;
            })
            .catch(err => {
                console.error('VAPID key fetch failed:', err);
                vapidKeyLoaded = false;
            });

        const authStore = {
            dbPromise: null,
            async getDB() {
                if (!('indexedDB' in window)) {
                    throw new Error('IndexedDB not supported');
                }

                if (!this.dbPromise) {
                    this.dbPromise = new Promise((resolve, reject) => {
                        const request = indexedDB.open('admin-auth', 1);

                        request.onupgradeneeded = () => {
                            const db = request.result;
                            if (!db.objectStoreNames.contains('session')) {
                                db.createObjectStore('session');
                            }
                        };

                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                }

                return this.dbPromise;
            },
            async savePassword(password) {
                try {
                    const db = await this.getDB();
                    await new Promise((resolve, reject) => {
                        const tx = db.transaction('session', 'readwrite');
                        tx.objectStore('session').put(password, 'password');
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error);
                    });
                } catch (error) {
                    console.error('Failed to save password to IndexedDB:', error);
                }
            },
            async getPassword() {
                try {
                    const db = await this.getDB();
                    return await new Promise((resolve, reject) => {
                        const tx = db.transaction('session', 'readonly');
                        const request = tx.objectStore('session').get('password');
                        request.onsuccess = () => resolve(request.result || null);
                        request.onerror = () => reject(request.error);
                    });
                } catch (error) {
                    console.error('Failed to load password from IndexedDB:', error);
                    return null;
                }
            },
            async clearPassword() {
                try {
                    const db = await this.getDB();
                    await new Promise((resolve, reject) => {
                        const tx = db.transaction('session', 'readwrite');
                        tx.objectStore('session').delete('password');
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => reject(tx.error);
                    });
                } catch (error) {
                    console.error('Failed to clear password from IndexedDB:', error);
                }
            }
        };

        const app = {
            password: null,
            currentVisitorId: null,
            eventSource: null,
            connectionStatus: 'disconnected',
            retryDelay: 1000, // Start at 1 second
            maxRetryDelay: 30000, // Cap at 30 seconds

            async login() {
                const password = document.getElementById('password-input').value;
                if (!password) return;

                // Validate password by trying to fetch threads first
                try {
                    const response = await fetch('/api/admin/threads', {
                        headers: {
                            'Authorization': `Bearer ${password}`
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 401) {
                            this.showError('Invalid password');
                            return;
                        }
                        throw new Error('Failed to validate password');
                    }

                    // Password is valid, store it
                    this.password = password;
                    await authStore.savePassword(password);

                    if (this.eventSource) {
                        this.eventSource.close();
                        this.eventSource = null;
                    }
                    this.retryDelay = 1000;

                    document.getElementById('password-input').value = '';
                    document.getElementById('login-error').classList.add('hidden');

                    // Load initial data
                    this.loadThreads();
                } catch (error) {
                    console.error('Login failed:', error);
                    this.showError('Login failed. Check your connection and try again.');
                }
            },

            async loadThreads() {
                if (!this.password) {
                    this.showLogin();
                    return;
                }

                try {
                    const response = await fetch('/api/admin/threads', {
                        headers: {
                            'Authorization': `Bearer ${this.password}`
                        }
                    });

                    if (!response.ok) {
                        if (response.status === 401) {
                            console.error('Authentication failed - clearing stored credentials');
                            await authStore.clearPassword();
                            this.password = null;
                            if (this.eventSource) {
                                this.eventSource.close();
                                this.eventSource = null;
                            }
                            this.setConnectionStatus('disconnected', 'Login required');
                            this.showLogin();
                            return;
                        }
                        throw new Error('Failed to load threads');
                    }

                    const data = await response.json();
                    this.renderThreads(data.threads);

                    this.showAppShell();

                    const threadListEl = document.getElementById('thread-list-screen');
                    const convoEl = document.getElementById('conversation-screen');

                    if (this.activeTab === 'inbox' && convoEl.classList.contains('hidden')) {
                        threadListEl.classList.remove('hidden');
                    } else {
                        threadListEl.classList.add('hidden');
                    }

                    if (this.activeTab === 'blog') {
                        document.getElementById('blog-screen').classList.remove('hidden');
                    }

                    // Start SSE for live updates
                    this.startSSE();

                    // Setup push notifications (with user gesture context)
                    this.setupPushNotifications();

                } catch (error) {
                    this.showError(error.message);
                }
            },

            startSSE() {
                if (this.eventSource) return;
                if (!this.password) {
                    return;
                }

                this.setConnectionStatus('connecting');
                this.eventSource = new EventSource(`/api/admin/stream?token=${encodeURIComponent(this.password)}`);

                this.eventSource.onopen = () => {
                    this.logEventSourceState('onopen');
                    this.setConnectionStatus('connected');
                    // Reset retry delay on successful connection
                    this.retryDelay = 1000;
                };

                this.eventSource.addEventListener('new-message', (event) => {
                    this.logEventSourceState('message');
                    const data = JSON.parse(event.data);

                    if (this.currentVisitorId === data.visitorId) {
                        this.appendMessage(data.message);
                    }

                    if (this.connectionStatus !== 'connected') {
                        this.setConnectionStatus('connected');
                    }

                    if (!this.currentVisitorId) {
                        this.loadThreads();
                    }
                });

                this.eventSource.onerror = (event) => {
                    this.logEventSourceState('onerror', event);
                    const readyState = this.eventSource ? this.eventSource.readyState : 2;
                    const CLOSED = typeof EventSource !== 'undefined' && 'CLOSED' in EventSource ? EventSource.CLOSED : 2;
                    const CONNECTING = typeof EventSource !== 'undefined' && 'CONNECTING' in EventSource ? EventSource.CONNECTING : 0;
                    const OPEN = typeof EventSource !== 'undefined' && 'OPEN' in EventSource ? EventSource.OPEN : 1;

                    if (readyState === CLOSED) {
                        console.error('SSE connection closed');
                        this.eventSource = null;

                        // Exponential backoff: double the delay, cap at maxRetryDelay
                        const currentDelay = this.retryDelay;
                        const retrySeconds = Math.ceil(currentDelay / 1000);

                        console.log(`SSE disconnected. Retrying in ${retrySeconds}s...`);
                        this.setConnectionStatus('disconnected', `Retrying in ${retrySeconds}s`);

                        setTimeout(() => {
                            if (!this.eventSource) {
                                this.startSSE();
                            }
                        }, currentDelay);

                        this.retryDelay = Math.min(this.retryDelay * 2, this.maxRetryDelay);
                        return;
                    }

                    if (readyState === CONNECTING) {
                        console.log('SSE reconnecting...');
                        this.setConnectionStatus('connecting');
                        return;
                    }

                    if (readyState === OPEN) {
                        console.warn('SSE error while connection is open', event);
                        if (this.connectionStatus !== 'connected') {
                            this.setConnectionStatus('connected');
                        }
                        return;
                    }

                    console.warn('SSE error with unexpected readyState', { readyState, event });
                };
            },

            appendMessage(message) {
                const container = document.getElementById('messages-container');
                if (!container) return;

                const msgDiv = document.createElement('div');
                msgDiv.className = `message ${message.from}`;
                msgDiv.style.opacity = '0';
                msgDiv.style.transition = 'opacity 0.3s ease-in';
                msgDiv.innerHTML = `
                    <div class="author">${message.from === 'david' ? 'You' : 'Visitor'}</div>
                    <div class="text">${this.escapeHtml(message.text)}</div>
                    <div class="time">${this.formatTime(message.ts)}</div>
                `;

                container.appendChild(msgDiv);

                // Fade in
                setTimeout(() => msgDiv.style.opacity = '1', 10);

                // Scroll to bottom
                setTimeout(() => container.scrollTop = container.scrollHeight, 100);
            },

            renderThreads(threads) {
                const container = document.getElementById('threads-container');

                if (!threads || threads.length === 0) {
                    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No conversations yet</p>';
                    this.updateBadge(0);
                    return;
                }

                // Calculate total unread count
                const totalUnread = threads.reduce((sum, t) => sum + (t.unreadFromVisitor || 0), 0);
                this.updateBadge(totalUnread);

                container.innerHTML = threads.map(thread => {
                    const lastMsg = thread.lastMessage;
                    const unread = thread.unreadFromVisitor;
                    const badge = unread > 0 ? `<span class="badge">${unread}</span>` : '';

                    return `
                        <div class="thread-item" onclick="app.openThread('${thread.visitorId}')">
                            <button class="delete-thread-btn" onclick="event.stopPropagation(); app.deleteThread('${thread.visitorId}')">üóëÔ∏è</button>
                            <div class="visitor-id">
                                ${thread.visitorId.substring(0, 16)}...
                                ${badge}
                            </div>
                            <div class="meta">
                                ${thread.messageCount} messages ‚Ä¢ ${thread.pagesVisited.join(', ')}
                            </div>
                            <div class="last-message">
                                <strong>${lastMsg.from === 'david' ? 'You' : 'Them'}:</strong>
                                ${this.escapeHtml(lastMsg.text)}
                            </div>
                        </div>
                    `;
                }).join('');
            },

            async openThread(visitorId) {
                this.currentVisitorId = visitorId;

                try {
                    const response = await fetch(`/api/threads/${visitorId}/messages`);
                    if (!response.ok) throw new Error('Failed to load messages');

                    const data = await response.json();
                    this.renderConversation(visitorId, data.messages);

                    // Show conversation screen
                    document.getElementById('thread-list-screen').classList.add('hidden');
                    document.getElementById('conversation-screen').classList.remove('hidden');

                    // Sync badge when viewing thread
                    this.syncBadgeCount();

                } catch (error) {
                    alert('Error loading conversation: ' + error.message);
                }
            },

            renderConversation(visitorId, messages) {
                document.getElementById('conv-title').textContent = `Visitor ${visitorId.substring(0, 16)}...`;

                const meta = messages.length > 0
                    ? `First seen: ${new Date(messages[0].ts).toLocaleString()}`
                    : 'No messages';
                document.getElementById('conv-meta').textContent = meta;

                const container = document.getElementById('messages-container');
                container.innerHTML = messages.map(m => `
                    <div class="message ${m.from}">
                        <div class="author">${m.from === 'david' ? 'You' : 'Visitor'}</div>
                        <div class="text">${this.escapeHtml(m.text)}</div>
                        <div class="time">${this.formatTime(m.ts)}</div>
                    </div>
                `).join('');

                // Scroll to bottom
                setTimeout(() => container.scrollTop = container.scrollHeight, 100);
            },

            async sendReply() {
                const textarea = document.getElementById('reply-text');
                const text = textarea.value.trim();

                if (!text || !this.currentVisitorId) return;
                if (!this.password) {
                    alert('Please log in again.');
                    this.showLogin();
                    return;
                }

                try {
                    const response = await fetch(`/api/admin/threads/${this.currentVisitorId}/reply`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.password}`
                        },
                        body: JSON.stringify({ text })
                    });

                    if (!response.ok) throw new Error('Failed to send reply');

                    // Show success
                    const successEl = document.getElementById('reply-success');
                    successEl.classList.remove('hidden');
                    setTimeout(() => successEl.classList.add('hidden'), 3000);

                    // Clear textarea
                    textarea.value = '';

                    // Reload conversation and sync badge
                    this.openThread(this.currentVisitorId);
                    await this.loadThreads(); // Refresh badge count

                } catch (error) {
                    alert('Error sending reply: ' + error.message);
                }
            },

            async deleteThread(visitorId) {
                if (!confirm('Are you sure you want to delete this thread? This cannot be undone.')) {
                    return;
                }

                if (!this.password) {
                    alert('Please log in again.');
                    this.showLogin();
                    return;
                }

                try {
                    const response = await fetch(`/api/admin/threads/${visitorId}`, {
                        method: 'DELETE',
                        headers: {
                            'Authorization': `Bearer ${this.password}`
                        }
                    });

                    if (!response.ok) throw new Error('Failed to delete thread');

                    // If we're viewing this thread, go back to list
                    if (this.currentVisitorId === visitorId) {
                        this.showThreadList();
                    } else {
                        // Just reload the thread list
                        this.loadThreads();
                    }

                } catch (error) {
                    alert('Error deleting thread: ' + error.message);
                }
            },

            showThreadList() {
                document.getElementById('conversation-screen').classList.add('hidden');
                this.switchTab('inbox', { skipFetch: false });
            },

            showLogin() {
                document.getElementById('login-screen').classList.remove('hidden');
                document.getElementById('thread-list-screen').classList.add('hidden');
                document.getElementById('conversation-screen').classList.add('hidden');
                document.getElementById('blog-screen').classList.add('hidden');
                document.getElementById('admin-tabs').classList.add('hidden');
            },

            refresh() {
                if (this.activeTab === 'blog') {
                    this.loadBlogPosts(true);
                } else {
                    this.loadThreads();
                }
            },

            showError(message) {
                const errorEl = document.getElementById('login-error');
                errorEl.textContent = message;
                errorEl.classList.remove('hidden');
            },

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            },

            formatTime(ts) {
                const date = new Date(ts);
                const now = new Date();
                const diff = now - date;

                if (diff < 60000) return 'just now';
                if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
                if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
                if (diff < 604800000) return `${Math.floor(diff / 86400000)}d ago`;
                return date.toLocaleString();
            },

            async setupPushNotifications() {
                if (!('serviceWorker' in navigator) || !('PushManager' in window)) return;
                if (!vapidKeyLoaded || !window.vapidPublicKey) return;
                if (!this.password) return;

                try {
                    const registration = await navigator.serviceWorker.ready;
                    let subscription = await registration.pushManager.getSubscription();

                    if (!subscription) {
                        const permission = await Notification.requestPermission();
                        if (permission !== 'granted') return;

                        subscription = await registration.pushManager.subscribe({
                            userVisibleOnly: true,
                            applicationServerKey: this.urlBase64ToUint8Array(window.vapidPublicKey)
                        });
                    }

                    // Always send subscription to server (survives server restarts)
                    const registerResponse = await fetch('/api/admin/push-subscribe', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.password}`
                        },
                        body: JSON.stringify(subscription)
                    });

                    if (registerResponse.status === 401) {
                        console.warn('Push subscription registration failed: invalid password');
                        await authStore.clearPassword();
                        this.password = null;
                        if (this.eventSource) {
                            this.eventSource.close();
                            this.eventSource = null;
                        }
                        this.setConnectionStatus('disconnected', 'Login required');
                        this.showLogin();
                        return;
                    }

                    if (!registerResponse.ok) {
                        throw new Error(`Push subscription registration failed (${registerResponse.status})`);
                    }
                } catch (error) {
                    console.error('Push notification setup failed:', error);
                }
            },

            urlBase64ToUint8Array(base64String) {
                const padding = '='.repeat((4 - base64String.length % 4) % 4);
                const base64 = (base64String + padding)
                    .replace(/\-/g, '+')
                    .replace(/_/g, '/');

                const rawData = window.atob(base64);
                const outputArray = new Uint8Array(rawData.length);

                for (let i = 0; i < rawData.length; ++i) {
                    outputArray[i] = rawData.charCodeAt(i);
                }
                return outputArray;
            },

            async syncBadgeCount() {
                // Re-fetch thread list to get current unread count and update badge
                // This is useful when viewing a thread or switching app focus
                try {
                    const response = await fetch('/api/admin/threads', {
                        headers: {
                            'Authorization': `Bearer ${this.password}`
                        }
                    });
                    if (!response.ok) return;

                    const data = await response.json();
                    const threads = data.threads || [];
                    const totalUnread = threads.reduce((sum, t) => sum + (t.unreadFromVisitor || 0), 0);
                    this.updateBadge(totalUnread);
                } catch (error) {
                    console.error('Error syncing badge count:', error);
                }
            },

            updateBadge(count) {
                if ('setAppBadge' in navigator) {
                    if (count > 0) {
                        navigator.setAppBadge(count);
                    } else {
                        navigator.clearAppBadge();
                    }
                }
            },

            setConnectionStatus(status, message) {
                this.connectionStatus = status;
                console.info('[connection-status]', status, message || '');
                const statusEl = document.getElementById('connection-status');
                const textEl = document.getElementById('connection-text');

                // Remove all status classes
                statusEl.classList.remove('connected', 'connecting', 'disconnected');

                if (status === 'connected') {
                    statusEl.classList.add('connected', 'show');
                    textEl.textContent = message || '‚óè  Connected';
                    // Hide after 2 seconds
                    setTimeout(() => statusEl.classList.remove('show'), 2000);
                } else if (status === 'connecting') {
                    statusEl.classList.add('connecting', 'show');
                    textEl.textContent = message || '‚óè  Connecting...';
                } else if (status === 'disconnected') {
                    statusEl.classList.add('disconnected', 'show');
                    textEl.textContent = message || '‚óè  Disconnected';
                }
        }
    };

        app.activeTab = 'inbox';
        app.blogPosts = [];
        app.currentBlogSlug = null;
        app.blogDraftKey = 'blog-editor-draft-v1';
        app.blogAutosaveTimer = null;
        app.previewMarkedConfigured = false;

        app.showAppShell = function() {
            const login = document.getElementById('login-screen');
            const tabs = document.getElementById('admin-tabs');
            if (login) login.classList.add('hidden');
            if (tabs) tabs.classList.remove('hidden');
            this.updateTabButtons();
        };

        app.updateTabButtons = function() {
            const inboxBtn = document.getElementById('tab-inbox');
            const blogBtn = document.getElementById('tab-blog');
            if (!inboxBtn || !blogBtn) return;
            inboxBtn.classList.toggle('active', this.activeTab === 'inbox');
            blogBtn.classList.toggle('active', this.activeTab === 'blog');
        };

        app.switchTab = function(tab, options = {}) {
            if (!this.password) {
                this.showLogin();
                return;
            }

            const { skipFetch = false, keepConversation = false } = options;
            this.activeTab = tab;
            this.showAppShell();
            this.updateTabButtons();

            const threadList = document.getElementById('thread-list-screen');
            const conversation = document.getElementById('conversation-screen');
            const blogScreen = document.getElementById('blog-screen');

            if (tab === 'inbox') {
                if (blogScreen) blogScreen.classList.add('hidden');
                if (!keepConversation) {
                    if (conversation) conversation.classList.add('hidden');
                    if (threadList) threadList.classList.remove('hidden');
                }
                if (!skipFetch) {
                    this.loadThreads();
                }
            } else if (tab === 'blog') {
                if (threadList) threadList.classList.add('hidden');
                if (conversation) conversation.classList.add('hidden');
                if (blogScreen) blogScreen.classList.remove('hidden');
                if (!skipFetch) {
                    this.loadBlogPosts();
                }
                this.renderBlogPreview();
            }
        };

        app.loadBlogPosts = async function(force = false) {
            if (!this.password) {
                this.showLogin();
                return;
            }

            const listEl = document.getElementById('blog-posts-list');
            if (!listEl) return;

            if (!force && this.blogPosts.length > 0) {
                this.renderBlogPosts();
                return;
            }

            listEl.innerHTML = '<div class="loading">Loading...</div>';

            try {
                const response = await fetch('/api/admin/blog/posts', {
                    headers: {
                        'Authorization': `Bearer ${this.password}`
                    }
                });

                if (response.status === 401) {
                    await authStore.clearPassword();
                    this.password = null;
                    this.showLogin();
                    return;
                }

                if (!response.ok) {
                    throw new Error('Failed to load posts');
                }

                const data = await response.json();
                this.blogPosts = data.posts || [];
                if (data.stats) {
                    this.setBlogStats(data.stats);
                }
                this.renderBlogPosts();
            } catch (error) {
                console.error('Failed to load blog posts:', error);
                listEl.innerHTML = `<div class="error">Unable to load posts. ${error instanceof Error ? error.message : error}</div>`;
            }
        };

        app.setBlogStats = function(stats) {
            const statsEl = document.getElementById('blog-stats');
            if (!statsEl) return;
            const totalPosts = stats?.totalPosts ?? this.blogPosts.length;
            const totalWords = stats?.totalWords ?? this.blogPosts.reduce((sum, post) => sum + (post.wordCount || 0), 0);
            statsEl.innerHTML = `
                <span>Total posts: ${totalPosts}</span>
                <span>Total words: ${totalWords}</span>
            `;
        };

        app.renderBlogPosts = function() {
            const listEl = document.getElementById('blog-posts-list');
            if (!listEl) return;

            if (!this.blogPosts.length) {
                listEl.innerHTML = '<p style="color:#666;">No posts yet ‚Äî start by creating one.</p>';
                return;
            }

            listEl.innerHTML = this.blogPosts.map(post => {
                const updated = new Date(post.updatedAt || post.publishedAt).toLocaleString();
                const published = new Date(post.publishedAt).toLocaleDateString();
                const statusLabel = post.status === 'published' ? 'Published' : 'Draft';
                const statusColor = post.status === 'published' ? '#2e7d32' : '#ff6f00';
                return `
                    <div class="blog-post-card">
                        <h3>${this.escapeHtml(post.title)}</h3>
                        <div class="meta">
                            <strong style="color:${statusColor};">${statusLabel}</strong> ‚Ä¢ ${published}
                        </div>
                        <div class="meta">
                            Slug: <code>${this.escapeHtml(post.slug)}</code> ‚Ä¢ ${post.wordCount || 0} words ‚Ä¢ Updated ${this.escapeHtml(updated)}
                        </div>
                        <div class="actions">
                            <button onclick="app.editBlogPost('${post.slug}')">Edit</button>
                            <button class="secondary" onclick="app.deleteBlogPost('${post.slug}')">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        };

        app.configurePreviewMarked = function() {
            if (this.previewMarkedConfigured) return;
            if (typeof window === 'undefined' || !window.marked) return;

            const renderer = new window.marked.Renderer();
            const defaultLink = renderer.link ? renderer.link.bind(renderer) : null;
            renderer.link = function(href, title, text) {
                if (!defaultLink) {
                    return `<a href="${href || '#'}">${text}</a>`;
                }
                const html = defaultLink(href, title, text);
                if (!href) return html;
                const isExternal = /^https?:\/\//i.test(href) && !href.startsWith(window.location.origin);
                if (!isExternal) return html;
                return html.replace('<a ', '<a target="_blank" rel="noopener noreferrer" ');
            };

            window.marked.use({ mangle: false, headerIds: true, renderer });
            if (window.hljs && typeof window.hljs.highlight === 'function') {
                window.marked.setOptions({
                    highlight(code, lang) {
                        try {
                            const valid = lang && window.hljs.getLanguage(lang) ? lang : 'plaintext';
                            return window.hljs.highlight(code, { language: valid }).value;
                        } catch {
                            return window.hljs.highlight(code, { language: 'plaintext' }).value;
                        }
                    }
                });
            }
            this.previewMarkedConfigured = true;
        };

        app.renderBlogPreview = function() {
            const previewEl = document.getElementById('blog-preview');
            if (!previewEl) return;

            this.configurePreviewMarked();

            const raw = this.getBlogFormRawValues();
            const title = raw.title.trim() || 'Untitled post';
            const summary = raw.summary.trim();
            const status = (raw.status || 'draft').toLowerCase();
            const statusLabel = status === 'published' ? 'Published' : 'Draft';
            const publishedAt = raw.publishedAt ? new Date(raw.publishedAt) : null;
            const publishedLabel = publishedAt && !Number.isNaN(publishedAt.valueOf())
                ? publishedAt.toLocaleString()
                : 'Not scheduled';
            const tagsList = raw.tags
                ? raw.tags.split(',').map(tag => tag.trim()).filter(Boolean)
                : [];

            if (!raw.content.trim()) {
                previewEl.innerHTML = `<p class="blog-preview-empty">Start typing to see the live preview.</p>`;
                return;
            }

            let renderedBody = '';
            if (window.marked) {
                renderedBody = window.marked.parse(raw.content);
            } else {
                renderedBody = `<pre>${this.escapeHtml(raw.content)}</pre>`;
            }

            const metaParts = [statusLabel];
            if (publishedAt) {
                metaParts.push(publishedLabel);
            }
            if (tagsList.length) {
                metaParts.push(tagsList.map(tag => `#${this.escapeHtml(tag)}`).join(' '));
            }

            previewEl.innerHTML = `
                <article class="blog-preview-article">
                    <h1>${this.escapeHtml(title)}</h1>
                    <p class="blog-preview-meta">${metaParts.join(' ‚Ä¢ ')}</p>
                    ${summary ? `<p class="blog-preview-summary">${this.escapeHtml(summary)}</p>` : ''}
                    ${renderedBody}
                </article>
            `;

            if (window.hljs && typeof window.hljs.highlightElement === 'function') {
                previewEl.querySelectorAll('pre code').forEach(block => {
                    window.hljs.highlightElement(block);
                });
            }
        };

        app.clearBlogStatus = function() {
            const successEl = document.getElementById('blog-editor-status');
            const errorEl = document.getElementById('blog-editor-error');
            if (successEl) successEl.classList.add('hidden');
            if (errorEl) errorEl.classList.add('hidden');
        };

        app.setBlogFormStatus = function(kind, message) {
            const successEl = document.getElementById('blog-editor-status');
            const errorEl = document.getElementById('blog-editor-error');
            if (!successEl || !errorEl) return;

            successEl.classList.add('hidden');
            errorEl.classList.add('hidden');

            if (!kind || !message) return;

            if (kind === 'success') {
                successEl.textContent = message;
                successEl.classList.remove('hidden');
                setTimeout(() => successEl.classList.add('hidden'), 4000);
            } else {
                errorEl.textContent = message;
                errorEl.classList.remove('hidden');
            }
        };

        app.getBlogFormRawValues = function() {
            return {
                title: document.getElementById('blog-title')?.value || '',
                slug: document.getElementById('blog-slug')?.value || '',
                summary: document.getElementById('blog-summary')?.value || '',
                tags: document.getElementById('blog-tags')?.value || '',
                heroImage: document.getElementById('blog-hero-image')?.value || '',
                status: document.getElementById('blog-status')?.value || 'draft',
                publishedAt: document.getElementById('blog-published-at')?.value || '',
                content: document.getElementById('blog-content')?.value || '',
            };
        };

        app.populateBlogForm = function(values) {
            const { title, slug, summary, tags, heroImage, status, publishedAt, content } = values;
            document.getElementById('blog-title').value = title || '';
            document.getElementById('blog-slug').value = slug || '';
            document.getElementById('blog-summary').value = summary || '';
            document.getElementById('blog-tags').value = Array.isArray(tags) ? tags.join(', ') : (tags || '');
            document.getElementById('blog-hero-image').value = heroImage || '';
            document.getElementById('blog-status').value = status || 'draft';
            document.getElementById('blog-published-at').value = publishedAt || '';
            document.getElementById('blog-content').value = content || '';
            this.renderBlogPreview();
        };

        app.resetBlogForm = function(clearDraft = true) {
            this.currentBlogSlug = null;
            this.setBlogFormStatus();
            this.populateBlogForm({
                title: '',
                slug: '',
                summary: '',
                tags: '',
                heroImage: '',
                status: 'draft',
                publishedAt: '',
                content: ''
            });
            document.getElementById('blog-editor-title').textContent = 'Create Post';
            if (clearDraft) {
                this.clearBlogDraft();
            }
        };

        app.collectBlogFormValues = function() {
            const raw = this.getBlogFormRawValues();
            const tags = raw.tags
                ? raw.tags.split(',').map(tag => tag.trim()).filter(Boolean)
                : [];
            const publishedAtIso = raw.publishedAt ? this.toIsoString(raw.publishedAt) : null;
            return {
                title: raw.title.trim(),
                slug: raw.slug.trim(),
                summary: raw.summary.trim(),
                tags,
                heroImage: raw.heroImage.trim(),
                status: raw.status || 'draft',
                publishedAt: publishedAtIso,
                content: raw.content,
                publishedAtLocal: raw.publishedAt
            };
        };

        app.newBlogPost = function() {
            this.resetBlogForm(false);
            this.restoreBlogDraft();
            this.renderBlogPreview();
        };

        app.editBlogPost = async function(slug) {
            if (!this.password) {
                this.showLogin();
                return;
            }

            try {
                const response = await fetch(`/api/admin/blog/posts/${slug}`, {
                    headers: {
                        'Authorization': `Bearer ${this.password}`
                    }
                });

                if (response.status === 401) {
                    await authStore.clearPassword();
                    this.password = null;
                    this.showLogin();
                    return;
                }

                if (!response.ok) {
                    throw new Error('Failed to load post');
                }

                const data = await response.json();
                const post = data.post;
                this.currentBlogSlug = post.slug;
                document.getElementById('blog-editor-title').textContent = `Editing ${post.slug}`;
                this.setBlogFormStatus();
                this.populateBlogForm({
                    title: post.title,
                    slug: post.slug,
                    summary: post.summary,
                    tags: post.tags,
                    heroImage: post.heroImage,
                    status: post.status,
                    publishedAt: this.toDatetimeLocal(post.publishedAt),
                    content: post.content
                });
                this.clearBlogDraft();
            } catch (error) {
                console.error('Failed to load post:', error);
                this.setBlogFormStatus('error', error instanceof Error ? error.message : 'Unknown error');
            }
        };

        app.submitBlogForm = async function(event) {
            event.preventDefault();
            if (!this.password) {
                this.showLogin();
                return;
            }

            const values = this.collectBlogFormValues();
            if (!values.title) {
                this.setBlogFormStatus('error', 'Title is required');
                return;
            }
            if (!values.content || !values.content.trim()) {
                this.setBlogFormStatus('error', 'Content is required');
                return;
            }

            const isEditing = Boolean(this.currentBlogSlug);
            const endpoint = isEditing
                ? `/api/admin/blog/posts/${this.currentBlogSlug}`
                : '/api/admin/blog/posts';
            const method = isEditing ? 'PATCH' : 'POST';

            const payload = {
                title: values.title,
                content: values.content,
                summary: values.summary || undefined,
                tags: values.tags,
                status: values.status,
                heroImage: values.heroImage || undefined,
                publishedAt: values.publishedAt || undefined,
            };

            if (values.slug) {
                payload.slug = values.slug;
            }

            try {
                const response = await fetch(endpoint, {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.password}`
                    },
                    body: JSON.stringify(payload)
                });

                if (response.status === 401) {
                    await authStore.clearPassword();
                    this.password = null;
                    this.showLogin();
                    return;
                }

                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to save post');
                }

                this.setBlogFormStatus('success', isEditing ? 'Post updated' : 'Post created');
                this.currentBlogSlug = data.post.slug;
                document.getElementById('blog-editor-title').textContent = `Editing ${data.post.slug}`;
                document.getElementById('blog-slug').value = data.post.slug;
                this.clearBlogDraft();
                this.renderBlogPreview();
                this.loadBlogPosts(true);
            } catch (error) {
                console.error('Failed to save post:', error);
                this.setBlogFormStatus('error', error instanceof Error ? error.message : 'Unknown error');
            }
        };

        app.deleteBlogPost = async function(slug) {
            if (!this.password) {
                this.showLogin();
                return;
            }
            if (!confirm('Delete this post permanently?')) {
                return;
            }

            try {
                const response = await fetch(`/api/admin/blog/posts/${slug}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${this.password}`
                    }
                });

                if (response.status === 401) {
                    await authStore.clearPassword();
                    this.password = null;
                    this.showLogin();
                    return;
                }

                if (!response.ok) {
                    const data = await response.json().catch(() => ({}));
                    throw new Error(data.error || 'Failed to delete post');
                }

                if (this.currentBlogSlug === slug) {
                    this.resetBlogForm();
                }

                this.loadBlogPosts(true);
            } catch (error) {
                console.error('Failed to delete post:', error);
                this.setBlogFormStatus('error', error instanceof Error ? error.message : 'Unknown error');
            }
        };

        app.saveBlogDraft = function() {
            if (this.currentBlogSlug) return;
            try {
                const raw = this.getBlogFormRawValues();
                localStorage.setItem(this.blogDraftKey, JSON.stringify(raw));
            } catch (error) {
                console.warn('Unable to save blog draft:', error);
            }
        };

        app.restoreBlogDraft = function() {
            try {
                const raw = localStorage.getItem(this.blogDraftKey);
                if (!raw) return;
                const draft = JSON.parse(raw);
                this.populateBlogForm(draft);
            } catch (error) {
                console.warn('Unable to restore blog draft:', error);
            }
        };

        app.clearBlogDraft = function() {
            try {
                localStorage.removeItem(this.blogDraftKey);
            } catch (error) {
                console.warn('Unable to clear blog draft:', error);
            }
        };

        app.scheduleBlogAutosave = function() {
            if (this.blogAutosaveTimer) {
                clearTimeout(this.blogAutosaveTimer);
            }
            this.blogAutosaveTimer = setTimeout(() => {
                this.saveBlogDraft();
            }, 600);
        };

        app.setupBlogAutosave = function() {
            const fields = [
                'blog-title',
                'blog-slug',
                'blog-summary',
                'blog-tags',
                'blog-hero-image',
                'blog-status',
                'blog-published-at',
                'blog-content'
            ];
            fields.forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        this.scheduleBlogAutosave();
                        this.renderBlogPreview();
                    });
                    el.addEventListener('change', () => {
                        this.scheduleBlogAutosave();
                        this.renderBlogPreview();
                    });
                }
            });
            this.restoreBlogDraft();
            this.renderBlogPreview();
        };

        app.toDatetimeLocal = function(iso) {
            if (!iso) return '';
            const date = new Date(iso);
            if (Number.isNaN(date.getTime())) return '';
            const pad = (num) => String(num).padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}T${pad(date.getHours())}:${pad(date.getMinutes())}`;
        };

        app.toIsoString = function(datetimeLocal) {
            if (!datetimeLocal) return '';
            const date = new Date(datetimeLocal);
            if (Number.isNaN(date.getTime())) return '';
            return date.toISOString();
        };

        app.logEventSourceState = function(context, event) {
            const source = this.eventSource;
            const state = source ? source.readyState : null;
            const stateName = state === 0 ? 'CONNECTING' : state === 1 ? 'OPEN' : state === 2 ? 'CLOSED' : 'UNKNOWN';
            const payload = { context, state: stateName, readyState: state, connectionStatus: this.connectionStatus };
            if (event) {
                payload.eventType = event.type;
            }
            console.debug('[sse]', payload);
        };

        // Register service worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
                .catch(err => console.error('Service Worker registration failed:', err));

            // Listen for messages from service worker (e.g., notification clicks)
            navigator.serviceWorker.addEventListener('message', (event) => {
                if (event.data.type === 'open-thread' && event.data.visitorId) {
                    app.openThread(event.data.visitorId);
                }
            });
        }

        // Restore password if available
        window.addEventListener('DOMContentLoaded', async () => {
            // Clean up legacy storage if it exists
            try {
                localStorage.removeItem('__admin_pwd');
            } catch (err) {
                // Ignore if localStorage is unavailable (e.g., private mode)
            }

            // Clear old token storage from previous auth system and migrate
            try {
                const db = await authStore.getDB();

                // Check if we have an old token (base64-like string longer than typical password)
                const storedValue = await new Promise((resolve, reject) => {
                    const tx = db.transaction('session', 'readonly');
                    const request = tx.objectStore('session').get('password');
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                // If stored value looks like an old token (long base64), clear it
                if (storedValue && storedValue.length > 40 && /^[A-Za-z0-9_-]+$/.test(storedValue)) {
                    console.log('Detected old session token, clearing...');
                    await authStore.clearPassword();
                }

                // Also clear any leftover 'token' key
                await new Promise((resolve) => {
                    try {
                        const tx = db.transaction('session', 'readwrite');
                        tx.objectStore('session').delete('token');
                        tx.oncomplete = () => resolve();
                        tx.onerror = () => resolve(); // Ignore errors
                    } catch {
                        resolve();
                    }
                });
            } catch (err) {
                console.log('Migration check failed:', err);
            }

            authStore.getPassword().then((password) => {
                if (password) {
                    app.password = password;
                    app.loadThreads();
                }
            });

            // Add Enter key handler for reply textarea
            const replyTextarea = document.getElementById('reply-text');
            if (replyTextarea) {
                replyTextarea.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        app.sendReply();
                    }
                });
            }

            // Add window focus listener to sync badge when app comes to foreground
            window.addEventListener('focus', () => {
                app.syncBadgeCount();
                console.log('[badge-sync] App focused, syncing badge count');
            });

            app.setupBlogAutosave();

            // Monitor notification permission changes
            if ('permissions' in navigator && 'query' in navigator.permissions) {
                navigator.permissions.query({ name: 'notifications' })
                    .then((result) => {
                        if (result.addEventListener) {
                            result.addEventListener('change', () => {
                                const status = Notification.permission;
                                console.log('[notification-permission] Permission changed to:', status);
                                if (status === 'granted') {
                                    app.setupPushNotifications();
                                }
                            });
                        }
                    })
                    .catch(err => console.warn('[notification-permission] Permission query failed:', err));
            }
        });
    </script>
</body>
</html>
